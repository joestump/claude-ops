{{define "session.html"}}
<div class="max-w-5xl">
    <div class="mb-6">
        <a href="/sessions" class="back-link">&larr; All sessions</a>
    </div>

    <div class="flex items-center gap-3 mb-6">
        <h1 class="text-2xl font-semibold">Session #{{.Session.ID}}</h1>
        <span class="badge-pill {{statusClass .Session.Status}}">{{.Session.Status}}</span>
    </div>

    {{/* Session metadata */}}
    <div class="card-base mb-6">
        <div class="grid grid-cols-2 md:grid-cols-4 gap-4 text-sm">
            <div>
                <div class="meta-label">Tier</div>
                <div>{{.Session.Tier}} / {{tierLabel .Session.Tier}}</div>
            </div>
            <div>
                <div class="meta-label">Model</div>
                <div class="font-mono">{{.Session.Model}}</div>
            </div>
            <div>
                <div class="meta-label">Started</div>
                <div class="font-mono text-xs">{{fmtTime .Session.StartedAt}}</div>
            </div>
            <div>
                <div class="meta-label">Duration</div>
                <div class="font-mono text-xs">{{fmtDuration .Session.StartedAt .Session.EndedAt}}</div>
            </div>
            <!-- Governing: SPEC-0012 REQ "Session Detail Shows Trigger Metadata" -->
            <div>
                <div class="meta-label">Trigger</div>
                <div>{{.Session.Trigger}}</div>
            </div>
            {{if .Session.CostUSD}}
            <div>
                <div class="meta-label">Cost</div>
                <div class="font-mono text-xs">{{fmtCost .Session.CostUSD}}</div>
            </div>
            {{end}}
            {{if .Session.NumTurns}}
            <div>
                <div class="meta-label">Turns</div>
                <div class="font-mono text-xs">{{intVal .Session.NumTurns}}</div>
            </div>
            {{end}}
            {{if .Session.DurationMs}}
            <div>
                <div class="meta-label">API Time</div>
                <div class="font-mono text-xs">{{fmtMs .Session.DurationMs}}</div>
            </div>
            {{end}}
        </div>
    </div>

    {{/* Governing: SPEC-0016 REQ "Dashboard Escalation Chain Display" — parent/child links and chain cost */}}
    {{if or .Session.ParentSession .Session.ChildSessions}}
    <div class="card-base mb-6">
        <div class="meta-label mb-2">Escalation Chain</div>
        {{if .Session.ParentSession}}
        <div class="text-sm mb-1">
            Escalated from <a href="/sessions/{{.Session.ParentSession.ID}}" class="text-accent hover:underline">Session #{{.Session.ParentSession.ID}}</a>
            <span class="text-muted">(Tier {{.Session.ParentSession.Tier}} / {{tierLabel .Session.ParentSession.Tier}})</span>
        </div>
        {{end}}
        {{range .Session.ChildSessions}}
        <div class="text-sm mb-1">
            Escalated to <a href="/sessions/{{.ID}}" class="text-accent hover:underline">Session #{{.ID}}</a>
            <span class="text-muted">(Tier {{.Tier}} / {{tierLabel .Tier}})</span>
            <span class="badge-pill {{statusClass .Status}}">{{.Status}}</span>
        </div>
        {{end}}
        {{if gt .Session.ChainCost 0.0}}
        <div class="text-xs text-muted mt-2">Chain total cost: {{fmtFloat .Session.ChainCost}}</div>
        {{end}}
    </div>
    {{end}}

    {{if .Session.PromptText}}
    <div class="card-base mb-6">
        <div class="meta-label mb-1">Ad-Hoc Prompt</div>
        <div class="text-sm">{{.Session.PromptText}}</div>
    </div>
    {{end}}

    {{/* Governing: SPEC-0011 "Session Page Layout" — response card above activity log */}}
    {{/* Governing: SPEC-0011 "Markdown Response Rendering" — renderMarkdown via goldmark */}}
    {{if .Session.Response}}
    <section class="mb-6">
        <h2 class="section-heading">Response</h2>
        <div class="card-base prose">
            {{renderMarkdown .Session.Response}}
        </div>
    </section>
    {{end}}

    {{/* Governing: SPEC-0011 "Session Page Layout" — activity log section */}}
    {{/* Governing: SPEC-0011 "SSE Streaming of Formatted Events" — hx-ext=sse for running sessions */}}
    <section>
        <h2 class="section-heading">Activity Log</h2>
        {{if eq .Session.Status "running"}}
        <div class="terminal" id="activity-log"
             hx-ext="sse"
             sse-connect="/sessions/{{.Session.ID}}/stream"
             sse-swap="message"
             hx-swap="beforeend">
        </div>
        <div class="session-controls">
            <button id="follow-btn" class="follow-btn follow-active" onclick="toggleFollow()">
                <span class="follow-dot"></span>
                <span id="follow-label">following</span>
            </button>
            <button class="stop-btn" onclick="document.getElementById('stop-modal').showModal()">
                &#x25A0; stop
            </button>
        </div>

        <dialog id="stop-modal" class="run-modal">
            <div class="run-modal-box">
                <div class="flex items-center justify-between mb-4">
                    <h2 class="text-base font-semibold">Stop session?</h2>
                    <button onclick="document.getElementById('stop-modal').close()"
                            class="text-muted hover:text-charcoal text-xl leading-none">&times;</button>
                </div>
                <p class="text-sm text-muted mb-5">The running agent will be killed immediately. Any in-progress remediation may be left in a partial state.</p>
                <div class="flex gap-3 justify-end">
                    <button type="button" onclick="document.getElementById('stop-modal').close()"
                            class="btn-secondary text-sm">Cancel</button>
                    <button type="button" id="stop-confirm-btn" class="btn-danger text-sm"
                            onclick="confirmStop({{.Session.ID}})">Stop session</button>
                </div>
            </div>
        </dialog>

        <script>
        (function() {
            var following = true;
            var terminal = document.getElementById('activity-log');
            var btn = document.getElementById('follow-btn');
            var label = document.getElementById('follow-label');
            var caughtUp = false; // true once initial buffer replay is done

            // Flag that suppresses the scroll handler while we are the ones scrolling.
            // Without this, our own programmatic scroll fires the handler, which then
            // checks atBottom against a stale (pre-new-content) scrollHeight and
            // incorrectly disables following.
            var scrollByCode = false;

            function scrollToBottom() {
                scrollByCode = true;
                // rAF ensures layout is complete so scrollHeight is fresh.
                requestAnimationFrame(function() {
                    window.scrollTo({ top: document.body.scrollHeight, behavior: caughtUp ? 'smooth' : 'instant' });
                    // Keep the flag set long enough to outlive the debounce below (200ms > 100ms).
                    setTimeout(function() { scrollByCode = false; }, 200);
                });
            }

            // Auto-scroll when new SSE content arrives.
            var catchupTimer = null;
            var observer = new MutationObserver(function() {
                if (following) {
                    scrollToBottom();
                }
                // Mark caught up after 500ms of no new mutations (buffer replay is done).
                if (!caughtUp) {
                    if (catchupTimer) clearTimeout(catchupTimer);
                    catchupTimer = setTimeout(function() { caughtUp = true; }, 500);
                }
            });
            observer.observe(terminal, { childList: true, subtree: true });

            // Scroll to bottom on initial page load so the user sees the latest output.
            scrollToBottom();

            // Detect manual scroll — disable follow when the user scrolls up.
            // Ignore scroll events that we triggered ourselves.
            var scrollTimer = null;
            window.addEventListener('scroll', function() {
                if (scrollByCode) return;
                if (scrollTimer) clearTimeout(scrollTimer);
                scrollTimer = setTimeout(function() {
                    if (scrollByCode) return;
                    var atBottom = (window.innerHeight + window.scrollY) >= (document.body.scrollHeight - 100);
                    if (!atBottom && following) {
                        following = false;
                        btn.classList.remove('follow-active');
                        label.textContent = 'follow';
                    } else if (atBottom && !following) {
                        following = true;
                        btn.classList.add('follow-active');
                        label.textContent = 'following';
                    }
                }, 100);
            });

            // Toggle follow on click.
            window.toggleFollow = function() {
                following = !following;
                if (following) {
                    btn.classList.add('follow-active');
                    label.textContent = 'following';
                    scrollToBottom();
                } else {
                    btn.classList.remove('follow-active');
                    label.textContent = 'follow';
                }
            };

            // When the SSE stream finishes, reload the page to show the completed
            // session with its rendered markdown response.
            // Guard flag prevents double-reload if both htmx:sseClose and the
            // custom "done" SSE event fire for the same session end.
            var doneHandled = false;
            function handleSessionDone() {
                if (doneHandled) return;
                doneHandled = true;

                following = false;
                observer.disconnect();
                btn.classList.remove('follow-active');
                label.textContent = 'scroll to output';
                btn.onclick = function() {
                    terminal.scrollIntoView({ behavior: 'smooth' });
                };

                // Attempt to close the underlying native EventSource so the browser
                // does not reconnect before we reload (the server also sends
                // retry:30000 to discourage reconnect, but this is belt-and-suspenders).
                try {
                    var es = htmx._data && htmx._data(terminal, 'sse-event-source');
                    if (es && es.readyState !== EventSource.CLOSED) { es.close(); }
                } catch (_) {}

                // 2.5 s gives the DB time to persist the completed status before
                // the reload checks it to decide whether to show SSE or static output.
                setTimeout(function() { window.location.reload(); }, 2500);
            }

            terminal.addEventListener('htmx:sseClose', handleSessionDone);
            terminal.addEventListener('done', handleSessionDone);

            window.confirmStop = function(sessionId) {
                var btn = document.getElementById('stop-confirm-btn');
                btn.disabled = true;
                btn.textContent = 'Stopping…';
                fetch('/sessions/' + sessionId + '/stop', { method: 'POST' })
                    .then(function() {
                        document.getElementById('stop-modal').close();
                        // Page will reload automatically when the SSE stream closes.
                    })
                    .catch(function() {
                        btn.disabled = false;
                        btn.textContent = 'Stop session';
                    });
            };
        })();
        </script>
        {{else}}
        <div class="terminal" id="activity-log">
            {{.Output}}
        </div>
        {{end}}
    </section>

    {{if .Session.LogFile}}
    <div class="mt-4 text-xs text-muted">
        Log file: <span class="font-mono">{{.Session.LogFile}}</span>
    </div>
    {{end}}
</div>
{{end}}
