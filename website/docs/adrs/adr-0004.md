---
sidebar_position: 4
sidebar_label: Apprise Notifications
status: accepted
date: 2025-06-01
---

# Use Apprise CLI for Universal Notification Abstraction

## Context and Problem Statement

Claude Ops is an autonomous infrastructure monitoring and remediation agent that runs on a schedule inside a Docker container. It needs to notify operators about three categories of events:

1. **Daily digests** summarizing health check results and uptime statistics.
2. **Auto-remediation reports** sent immediately after a successful fix, describing what was wrong, what action was taken, and verification results.
3. **Human attention alerts** sent when remediation fails or cooldown limits are exceeded, requiring manual intervention.

Operators use a wide variety of notification channels depending on their organization: some use Slack, others Discord or Telegram, many rely on email, and some prefer lightweight push services like ntfy. Claude Ops needs to support all of these without coupling its core logic to any single notification provider. The notification mechanism must be configurable at deploy time with zero code changes, and it must degrade gracefully (silent no-op) when no notification target is configured.

## Decision Drivers

- **Breadth of supported channels.** Operators should not be forced into a specific notification ecosystem. The solution must cover email, chat platforms (Slack, Discord, Telegram, Matrix), push services (ntfy, Pushover, Gotify), paging systems (PagerDuty, Opsgenie), and more.
- **Zero application code.** Claude Ops is an AI agent runbook with no traditional application code. Notifications must be invocable from shell commands within markdown prompts, not from a compiled application or library API.
- **Configuration simplicity.** A single environment variable should be sufficient to add, remove, or change notification targets. No config files, no service-specific credential blocks, no per-channel setup.
- **Graceful degradation.** If no notification URLs are configured, the system must silently skip notifications without errors or log noise.
- **Container-friendly.** The solution must install cleanly into a Node.js-based Docker image without heavy dependencies, and must not require running additional services or sidecars.
- **Minimal operational burden.** Adding a new notification channel should require changing only the environment variable, not rebuilding the image or modifying prompts.

## Considered Options

1. **Apprise CLI** -- URL-based multi-channel notification tool supporting 80+ services
2. **Direct API integrations per service** -- custom `curl` calls to Slack webhooks, SMTP for email, etc.
3. **AWS SNS / cloud notification service** -- managed pub/sub from a cloud provider
4. **Webhook-only approach** -- expose a single webhook interface and let operators connect it to their preferred service

## Decision Outcome

Chosen option: **Apprise CLI**, because it provides universal notification coverage through a single CLI tool and a single environment variable (`CLAUDEOPS_APPRISE_URLS`), requires no application code, installs as a single `pip install`, and degrades gracefully when unconfigured.

### Implementation

- **Installation:** Added to the Docker image via `pip3 install --break-system-packages apprise` (`Dockerfile`, line 15).
- **Configuration:** A single environment variable `CLAUDEOPS_APPRISE_URLS` holds comma-separated Apprise URLs. Defined in `docker-compose.yaml` (lines 13-17) and passed to the Claude agent via the entrypoint system prompt (`entrypoint.sh`, lines 79-81).
- **Usage in prompts:** Tier 2 (`prompts/tier2-investigate.md`, Step 5) and Tier 3 (`prompts/tier3-remediate.md`, Step 5) invoke Apprise directly from shell commands embedded in their markdown instructions.
- **Graceful skip:** The runbook instructs the agent to check whether `$CLAUDEOPS_APPRISE_URLS` is set before invoking Apprise. If empty, notifications are silently skipped.

### Consequences

#### Positive

- Operators can target any combination of 80+ notification services by setting a single environment variable.
- Adding or changing notification channels requires no image rebuild, no code change, and no prompt modification.
- The CLI interface fits naturally into Claude Ops' shell-command-in-markdown execution model.
- Apprise is a single Python package with no external service dependencies.
- Multiple notification targets can be configured simultaneously (e.g., ntfy for push + email for audit trail) by comma-separating URLs.

#### Negative

- Introduces a Python dependency into a Node.js-based container image (requires `python3` and `pip3` in the base image).
- Apprise URL syntax must be learned; each notification service has its own URL scheme (e.g., `ntfy://`, `slack://`, `mailto://`).
- Apprise is a community-maintained open-source project; a breaking change or abandonment would require migration.
- No built-in delivery confirmation or retry logic; if a notification fails to send, the agent continues without re-attempting.

## Pros and Cons of the Options

### Apprise CLI

Apprise is a Python CLI and library that provides a unified notification interface for 80+ services. Each target is configured as a URL, and multiple targets can be combined in a single comma-separated string.

- Good, because it supports 80+ notification services out of the box (email, Slack, Discord, Telegram, ntfy, PagerDuty, Pushover, Matrix, Gotify, and many more).
- Good, because configuration is a single environment variable containing comma-separated URLs.
- Good, because it is a CLI tool, which aligns with Claude Ops' execution model of running shell commands from markdown prompts.
- Good, because it installs as a single `pip install` with no additional infrastructure.
- Good, because it degrades gracefully: if no URLs are provided, the agent simply skips the call.
- Good, because adding a new notification channel requires only appending a URL to the env var.
- Bad, because it adds a Python runtime dependency to a Node.js-based image, increasing image size.
- Bad, because Apprise URL syntax varies per service and must be referenced from Apprise documentation.
- Bad, because it is a community-maintained project with no commercial support or SLA.
- Bad, because there is no built-in retry or delivery guarantee mechanism.

### Direct API integrations per service

Each notification service is called directly using `curl` or service-specific CLI tools. For example, Slack via incoming webhook, email via `sendmail` or `curl` to an SMTP relay, ntfy via HTTP POST.

- Good, because there are no additional dependencies beyond `curl`, which is already in the image.
- Good, because each integration is simple and transparent (a single `curl` command).
- Good, because there is no abstraction layer that could break or need updating.
- Bad, because every new notification channel requires writing and maintaining a new integration.
- Bad, because configuration becomes complex: each service needs its own set of environment variables (webhook URL, SMTP credentials, API tokens).
- Bad, because the agent prompts must include service-specific notification logic, coupling the runbook to specific providers.
- Bad, because supporting multiple channels simultaneously requires duplicating notification calls throughout the prompts.
- Bad, because authentication and payload formats differ per service, increasing the surface area for errors.

### AWS SNS / cloud notification service

Use a managed cloud notification service (AWS SNS, Google Cloud Pub/Sub, Azure Notification Hubs) to fan out notifications to subscribed endpoints.

- Good, because managed services provide delivery guarantees, retries, and monitoring.
- Good, because SNS supports email, SMS, HTTP endpoints, Lambda, SQS, and mobile push.
- Good, because fan-out to multiple subscribers is a built-in capability.
- Bad, because it requires a cloud provider account and incurs per-message costs.
- Bad, because it introduces a hard dependency on a specific cloud provider, reducing portability.
- Bad, because it requires IAM credentials and network access to the cloud API from the container.
- Bad, because initial setup (creating topics, managing subscriptions) is significantly more complex than setting an environment variable.
- Bad, because it is overkill for the notification volume of a single-instance monitoring agent.
- Bad, because Claude Ops is designed to run anywhere (home lab, VPS, air-gapped networks), and requiring cloud access contradicts this.

### Webhook-only approach

Expose a single generic webhook interface: the agent sends a POST request with a JSON payload to a user-configured URL, and operators are responsible for routing it to their notification service (e.g., via Zapier, n8n, or a custom relay).

- Good, because it has zero dependencies: just `curl` with a JSON payload.
- Good, because it is maximally flexible: operators can route the webhook to any downstream service.
- Good, because the agent's notification logic is a single `curl` call regardless of the target.
- Bad, because it shifts the integration burden to the operator, who must set up and maintain a relay or automation platform.
- Bad, because it adds an additional point of failure (the relay service) between the agent and the actual notification.
- Bad, because operators who just want a Slack message or an email now need to run additional infrastructure.
- Bad, because there is no standardized webhook format that all notification services accept, so the relay must transform payloads.
- Bad, because multi-channel delivery requires the operator to configure fan-out in their relay, rather than it being handled natively.
